LoraConfig:
  # LoraConfig
  r: 8  # Lora attention dimension (the "rank")
  target_modules: null  # The names of the modules to apply the adapter to. If this is specified, only the modules with the specified names will be replaced. When passing a string, a regex match will be performed. When passing a list of strings, either an exact match will be performed or it is checked if the name of the module ends with any of the passed strings. If this is specified as 'all-linear', then all linear/Conv1D modules are chosen, excluding the output layer. If this is not specified, modules will be chosen according to the model architecture. If the architecture is not known, an error will be raised -- in this case, you should specify the target modules manually.
  lora_alpha: 8  # The alpha parameter for Lora scaling.
  lora_dropout: 0.0  # The dropout probability for Lora layers
  fan_in_fan_out: False  # Set this to True if the layer to replace stores weight like (fan_in, fan_out). For example, gpt-2 uses `Conv1D` which stores weights like (fan_in, fan_out) and hence this should be set to `True`.
  bias: 'none'  # Bias type for LoRA. Can be 'none', 'all' or 'lora_only'. If 'all' or 'lora_only', the corresponding biases will be updated during training. Be aware that this means that, even when disabling the adapters, the model will not produce the same output as the base model would have without adaptation.
  use_rslora: False  # When set to True, uses <a href='https://doi.org/10.48550/arXiv.2312.03732'>Rank-Stabilized LoRA</a> which sets the adapter scaling factor to `lora_alpha/math.sqrt(r)`, since it was proven to work better. Otherwise, it will use the original default value of `lora_alpha/r`.
  modules_to_save: null  # List of modules apart from adapter layers to be set as trainable and saved in the final checkpoint.
  init_lora_weights: True  # How to initialize the weights of the adapter layers. Passing True (default) results in the default initialization from the reference implementation from Microsoft. Passing 'gaussian' results in Gaussian initialization scaled by the LoRA rank for linear and layers. Setting the initialization to False leads to completely random initialization and is discouraged. Pass `'loftq'` to use LoftQ initialization. Passing 'pissa' results in the initialization of PiSSA, which converge more rapidly than LoRA and ultimately achieve superior performance. Moreover, PiSSA reduces the quantization error compared to QLoRA, leading to further enhancements. Passing 'pissa_niter_[number of iters]' initiates Fast-SVD-based PiSSA initialization, where [number of iters] indicates the number of subspace iterations to perform FSVD, and must be a nonnegative integer. When the [number of iters] is set to 16, it can complete the initialization of a 7b model within seconds, and the training effect is approximately equivalent to using SVD. For more information, see <a href='https://arxiv.org/abs/2404.02948'>Principal Singular values and Singular vectors Adaptation</a>.
  layers_to_transform: null  # The layer indices to transform. If a list of ints is passed, it will apply the adapter to the layer indices that are specified in this list. If a single integer is passed, it will apply the transformations on the layer at this index.
  layers_pattern: null  # The layer pattern name, used only if `layers_to_transform` is different from `None`.
  rank_pattern: {}  # The mapping from layer names or regexp expression to ranks which are different from the default rank specified by `r`.
  alpha_pattern: {}  # The mapping from layer names or regexp expression to alphas which are different from the default alpha specified by `lora_alpha`.
  megatron_config: null  # The TransformerConfig arguments for Megatron. It is used to create LoRA's parallel linear layer. You can get it like this, `core_transformer_config_from_args(get_args())`, these two functions being from Megatron. The arguments will be used to initialize the TransformerConfig of Megatron. You need to specify this parameter when you want to apply LoRA to the ColumnParallelLinear and RowParallelLinear layers of megatron.
  megatron_core: 'megatron.core'  # The core module from Megatron to use, defaults to `"megatron.core"`.
  loftq_config: {}  # The configuration of LoftQ. If this is not None, then LoftQ will be used to quantize the backbone weights and initialize Lora layers. Also pass `init_lora_weights='loftq'`. Note that you should not pass a quantized model in this case, as LoftQ will quantize the model itself.
  use_dora: False  # Enable 'Weight-Decomposed Low-Rank Adaptation' (DoRA). This technique decomposes the updates of the weights into two parts, magnitude and direction. Direction is handled by normal LoRA, whereas the magnitude is handled by a separate learnable parameter. This can improve the performance of LoRA especially at low ranks. Right now, DoRA only supports linear and Conv2D layers. DoRA introduces a bigger overhead than pure LoRA, so it is recommended to merge weights for inference. For more information, see https://arxiv.org/abs/2402.09353.
  layer_replication: null  # Build a new stack of layers by stacking the original model layers according to the ranges specified. This allows expanding (or shrinking) the model without duplicating the base model weights. The new layers will all have separate LoRA adapters attached to them.

  # PeftConfig
  peft_type: null  # The type of Peft method to use.
  task_type: null  # The type of task to perform.
  inference_mode: False  # Whether to use the Peft model in inference mode.

  # PeftConfigMixin
  auto_mapping: null  # "An auto mapping dict to help retrieve the base model class if needed."

  base_model_name_or_path: null
  revision: null
  
SFTConfig:

  # TrainingArguments

  dataset_text_field: null  # The name of the text field of the dataset, in case this is passed by a user, the trainer will automatically create a `ConstantLengthDataset` based on the `dataset_text_field` argument. Defaults to null.
  packing: False  # Used only in case `dataset_text_field` is passed. This argument is used by the `ConstantLengthDataset` to pack the sequences of the dataset. Defaults to False.
  max_seq_length: null  # The maximum sequence length to use for the `ConstantLengthDataset` and for automatically creating the Dataset. Defaults to min of the smaller of the `tokenizer.model_max_length` and `1024`.
  dataset_num_proc: null  # The number of workers to use to tokenize the data. Only used when `packing=False`. Defaults to null.
  dataset_batch_size: 1000  # The number of examples to tokenize per batch. If batch_size <= 0 or batch_size == null, tokenize the full dataset as a single batch. Defaults to 1000.
  neftune_noise_alpha: null  # If not `null`, this will activate NEFTune noise embeddings. This has been proven to drastically improve model performances for instruction fine-tuning. Check out the original paper here: https://arxiv.org/abs/2310.05914 and the original code here: https://github.com/neelsjain/NEFTune
  model_init_kwargs: null  # Dict of Optional kwargs to pass when instantiating the model from a string.
  dataset_kwargs: null  # Dict of Optional kwargs to pass when creating packed or non-packed datasets
  eval_packing: null  # Whether to pack the eval dataset as well. Defaults to `packing` if `null` is passed.
  num_of_sequences: null  # The number of sequences to use for the `ConstantLengthDataset`. Defaults to `1024`.
  chars_per_token: 3.6  # The number of characters per token to use for the `ConstantLengthDataset`. Defaults to `3.6`. You can check how this is computed in the stack-llama example: https://github.com/huggingface/trl/blob/08f550674c553c36c51d1027613c29f14f3676a5/examples/stack_llama/scripts/supervised_finetuning.py#L53.
  
PPOConfig:
  exp_name: main  # the name of this experiment (by default is the file name without the extension name)
  seed: 0  # Seed value for random generations
  log_with: null  # Log with either 'wandb' or 'tensorboard', check  https://huggingface.co/docs/accelerate/usage_guides/tracking for more details
  task_name: null  # Name of task to use - used only for tracking purposes
  model_name: gpt2  # Name of model to use - used only for tracking purposes
  query_dataset: imdb  # Name of dataset to query - used only for tracking purposes
  reward_model: sentiment-analysis:lvwerra/distilbert-imdb  # The reward model to use - used only for tracking purposes
  remove_unused_columns: True  # Remove unused columns from the dataset if `datasets.Dataset` is used
  tracker_kwargs: {}  # Keyword arguments for the tracker (e.g. python ppo.py --tracker_kwargs='{"wandb": {"entity": "my_wandb_entity", "name": "my_exp_name"}}'
  accelerator_kwargs: {} # Keyword arguments for the accelerator
  project_kwargs: {}  # Keyword arguments for the accelerator project config (e.g. `logging_dir`)
  tracker_project_name: trl  # Name of project to use for tracking
  push_to_hub_if_best_kwargs: {}  # Keyword arguments for pushing model to the hub during training (e.g. repo_id)

  # hyperparameters
  steps: 20000  # Number of training steps
  learning_rate: 1.41e-5  # Adam learning rate
  adap_kl_ctrl: True  # Use adaptive KL control, otherwise linear
  init_kl_coef: 0.2   # Initial KL penalty coefficient (used for adaptive and linear control)
  kl_penalty: kl  # kl penalty options: 'kl': model_logp - ref_logp,  'abs': abs(kl),  'mse': mean squared error mse(kl) and 'full': the actual kl for all tokens in the distribution
  target: 6  # Target KL value for adaptive KL control
  horizon: 10000  # Horizon for adaptive KL control
  gamma: 1  # Gamma parameter for advantage calculation
  lam: 0.95  # Lambda parameter for advantage calculation
  cliprange: 0.2  # Range for clipping in PPO policy gradient loss
  cliprange_value: 0.2  # Range for clipping values in loss calculation
  vf_coef: 0.1  # Scaling factor for value loss
  batch_size: 128  # Number of samples per optimisation step
  mini_batch_size: 128  # Number of samples optimized in each mini batch
  gradient_accumulation_steps: 1  # The number of gradient accumulation steps
  world_size: null  # The world size for distributed training
  ppo_epochs: 4  # Number of optimisation epochs per batch of samples
  max_grad_norm: null  # Maximum gradient norm for gradient clipping
  optimize_device_cache: False  # Optimize device cache for slightly more memory-efficient training
  early_stopping: False  # Whether to stop the PPO optimization loop early is the KL too high
  target_kl: 1  # Stop early if we exceed this value by over 50%
  compare_steps: 1  # Number of steps between comparison of the current reward with the best seen so far
  ratio_threshold: 10.0  # Skip mini-batches with high PPO ratios that can cause loss spikes
  use_score_scaling: False  # Use score scaling
  use_score_norm: False  # Use score normalization. Only applicable if use_score_scaling is True
  score_clip: null  # Score clipping
  whiten_rewards: False  # Whiten the rewards before compute advantages
  gradient_checkpointing: False  # Enable gradient checkpointing

DPOConfig:

  # TrainingArguments

  beta: 0.1  # The beta factor in DPO loss. Higher beta means less divergence from the initial policy. For the IPO loss, beta is the regularization parameter denoted by tau in the paper.
  label_smoothing: 0  # The robust DPO label smoothing parameter from the [cDPO](https://ericmitchell.ai/cdpo.pdf) report and [Robust DPO](https://arxiv.org/abs/2403.00409) paper that should be between 0 and 0.5.
  loss_type: sigmoid  # The type of DPO loss to use. Either `"sigmoid"` the default DPO loss,`"hinge"` loss from [SLiC](https://arxiv.org/abs/2305.10425) paper, `"ipo"` from [IPO](https://arxiv.org/abs/2310.12036) paper, `"bco_pair"` from [BCO](https://arxiv.org/abs/2404.04656) paper or `"robust"` from [Robust DPO](https://arxiv.org/abs/2403.00409) paper, "aot" and "aot_pair" from alignment via optimal transport
  label_pad_token_id: -100  # The label pad token id. This argument is required if you want to use the default data collator.
  padding_value : null  # The padding value if it is different to the tokenizer's pad_token_id.
  truncation_mode: keep_end  # The truncation mode to use, either `keep_end` or `keep_start`. This argument is required if you want to use the default data collator.
  max_length: null  # The maximum length of the sequences in the batch. This argument is required if you want to use the default data collator.
  max_prompt_length: null  # The maximum length of the prompt. This argument is required if you want to use the default data collator.
  max_target_length: null  # The maximum length of the target. This argument is required if you want to use the default data collator and your model is an encoder-decoder.
  is_encoder_decoder: null  # If no model is provided, we need to know if the model_init returns an encoder-decoder.
  disable_dropout: True  # Whether or not to disable dropouts in `model` and `ref_model`.
  generate_during_eval: False  # Whether to sample and log generations during evaluation step.
  precompute_ref_log_probs: False  # Flag to precompute reference model log probabilities for training and evaluation datasets. This is useful if you want to train without the reference model and reduce the total GPU memory needed.
  dataset_num_proc: null  # The number of workers to use to tokenize the data. Defaults to null.
  model_init_kwargs: null  # Dict of Optional kwargs to pass when instantiating the model from a string
  ref_model_init_kwargs: null  # Dict of Optional kwargs to pass when instantiating the ref model from a string
  model_adapter_name: null  # Name of the train target PEFT adapter, when using LoRA with multiple adapters.
  ref_adapter_name: null  # Name of the reference PEFT adapter, when using LoRA with multiple adapters.
  reference_free: False  # If True, we ignore the _provided_ reference model and implicitly use a reference model that assigns equal probability to all responses.
  force_use_ref_model: False  # In case one passes a PEFT model for the active model and you want to use a different model for the ref_model, set this flag to `True`.
  f_divergence_type: reverse_kl  # The type of f-divergence regularization function to compute divergence between policy and reference model. This argument is optional, defaults to `FDivergenceType.REVERSE_KL`.
  f_alpha_divergence_coef: 1.0  # The alpha coef in alpha-divergence(u^-alpha) regularization function for DPO loss.
  sync_ref_model: False  # The flag for syncing reference model during training from the [TR-DPO](https://arxiv.org/pdf/2404.09656) paper.
  ref_model_mixup_alpha: 0.9  # The alpha parameter from the [TR-DPO](https://arxiv.org/pdf/2404.09656) paper.
  ref_model_sync_steps: 64  # The tau parameter from the [TR-DPO](https://arxiv.org/pdf/2404.09656) paper.
  rpo_alpha: null  # The alpha parameter from the [RPO](https://arxiv.org/pdf/2404.19733) paper. If null, no weighting is applied and the loss is the same as the DPO loss.

TrainingArguments:
  output_dir: <MANDATORY>  # The output directory where the model predictions and checkpoints will be written.
  overwrite_output_dir: False  # If `True`, overwrite the content of the output directory. Use this to continue training if `output_dir` points to a checkpoint directory.
  do_train: False  # Whether to run training or not. This argument is not directly used by [`Trainer`], it's intended to be used by your training/evaluation scripts instead. See the [example scripts](https://github.com/huggingface/transformers/tree/main/examples) for more details.
  do_eval: False  # Whether to run evaluation on the validation set or not. Will be set to `True` if `eval_strategy` is different from `"no"`. This argument is not directly used by [`Trainer`], it's intended to be used by your training/evaluation scripts instead. See the [example scripts](https://github.com/huggingface/transformers/tree/main/examples) for more details.
  do_predict: False  # Whether to run predictions on the test set or not. This argument is not directly used by [`Trainer`], it's intended to be used by your training/evaluation scripts instead. See the [example scripts](https://github.com/huggingface/transformers/tree/main/examples) for more details.
  prediction_loss_only: False  # When performing evaluation and generating predictions, only returns the loss.
  per_device_train_batch_size: 8  # The batch size per GPU/XPU/TPU/MPS/NPU core/CPU for training.
  per_device_eval_batch_size: 8  # The batch size per GPU/XPU/TPU/MPS/NPU core/CPU for evaluation.
  per_gpu_train_batch_size: null
  per_gpu_eval_batch_size: null
  gradient_accumulation_steps: 1  # Number of updates steps to accumulate the gradients for, before performing a backward/update pass. When using gradient accumulation, one step is counted as one step with backward pass. Therefore, logging, evaluation, save will be conducted every `gradient_accumulation_steps * xxx_step` training examples.
  eval_accumulation_steps: null  # Number of predictions steps to accumulate the output tensors for, before moving the results to the CPU. If left unset, the whole predictions are accumulated on GPU/NPU/TPU before being moved to the CPU (faster but requires more memory).
  eval_delay: 0  # Number of epochs or steps to wait for before the first evaluation can be performed, depending on the eval_strategy.
  learning_rate: 5e-05  # The initial learning rate for [`AdamW`] optimizer.
  weight_decay: 0.0  # The weight decay to apply (if not zero) to all layers except all bias and LayerNorm weights in [`AdamW`] optimizer.
  adam_beta1: 0.9  # The beta1 hyperparameter for the [`AdamW`] optimizer.
  adam_beta2: 0.999  # The beta2 hyperparameter for the [`AdamW`] optimizer.
  adam_epsilon: 1e-08  # The epsilon hyperparameter for the [`AdamW`] optimizer.
  max_grad_norm: 1.0  # Maximum gradient norm (for gradient clipping).
  num_train_epochs: 3.0  # Total number of training epochs to perform (if not an integer, will perform the decimal part percents of the last epoch before stopping training).
  max_steps: -1  # If set to a positive number, the total number of training steps to perform. Overrides `num_train_epochs`. For a finite dataset, training is reiterated through the dataset (if all data is exhausted) until `max_steps` is reached.
  lr_scheduler_type: 'linear'  # The scheduler type to use. See the documentation of [`SchedulerType`] for all possible values.
  lr_scheduler_kwargs: {}  # The extra arguments for the lr_scheduler. See the documentation of each scheduler for possible values.
  warmup_ratio: 0.0  # Ratio of total training steps used for a linear warmup from 0 to `learning_rate`.
  warmup_steps: 0  # Number of steps used for a linear warmup from 0 to `learning_rate`. Overrides any effect of `warmup_ratio`.
  log_level: 'passive'  # Logger log level to use on the main process. Possible choices are the log levels as strings: 'debug', 'info', 'warning', 'error' and 'critical', plus a 'passive' level which doesn't set anything and keeps the current log level for the Transformers library (which will be `"warning"` by default).
  log_level_replica: 'warning'  # Logger log level to use on replicas. Same choices as `log_level`"
  log_on_each_node: True  # In multinode distributed training, whether to log using `log_level` once per node, or only on the main node.
  logging_dir: null  # [TensorBoard](https://www.tensorflow.org/tensorboard) log directory. Will default to *output_dir/runs/**CURRENT_DATETIME_HOSTNAME***.
  logging_strategy: 'steps'  # The logging strategy to adopt during training. Possible values are: - `"no"`: No logging is done during training. - `"epoch"`: Logging is done at the end of each epoch. - `"steps"`: Logging is done every `logging_steps`.
  logging_first_step: False  # Whether to log the first `global_step` or not.
  logging_steps: 500  # Number of update steps between two logs if `logging_strategy="steps"`. Should be an integer or a float in range `[0,1)`. If smaller than 1, will be interpreted as ratio of total training steps.
  logging_nan_inf_filter: True   # Whether to filter `nan` and `inf` losses for logging. If set to `True` the loss of every step that is `nan` or `inf` is filtered and the average loss of the current logging window is taken instead. `logging_nan_inf_filter` only influences the logging of loss values, it does not change the behavior the gradient is computed or applied to the model.
  save_strategy: 'steps'  # The checkpoint save strategy to adopt during training. Possible values are: - `"no"`: No save is done during training. - `"epoch"`: Save is done at the end of each epoch. - `"steps"`: Save is done every `save_steps`.
  save_steps: 500  # Number of updates steps before two checkpoint saves if `save_strategy="steps"`. Should be an integer or a float in range `[0,1)`. If smaller than 1, will be interpreted as ratio of total training steps. 
  save_total_limit: null  # If a value is passed, will limit the total amount of checkpoints. Deletes the older checkpoints in `output_dir`. When `load_best_model_at_end` is enabled, the "best" checkpoint according to `metric_for_best_model` will always be retained in addition to the most recent ones. For example, for `save_total_limit=5` and `load_best_model_at_end`, the four last checkpoints will always be retained alongside the best model. When `save_total_limit=1` and `load_best_model_at_end`, it is possible that two checkpoints are saved: the last one and the best one (if they are different).
  save_safetensors: True  # Use [safetensors](https://huggingface.co/docs/safetensors) saving and loading for state dicts instead of default `torch.load` and `torch.save`.
  save_on_each_node: False  # When doing multi-node distributed training, whether to save models and checkpoints on each node, or only on the main one. This should not be activated when the different nodes use the same storage as the files will be saved with the same names for each node.
  save_only_model: False  # When checkpointing, whether to only save the model, or also the optimizer, scheduler & rng state. Note that when this is true, you won't be able to resume training from checkpoint. This enables you to save storage by not storing the optimizer, scheduler & rng state. You can only load the model using `from_pretrained` with this option set to `True`.
  no_cuda: False
  use_cpu: False  # Whether or not to use cpu. If set to False, we will use cuda or mps device if available.
  use_mps_device: False  
  seed: 42  # Random seed that will be set at the beginning of training. To ensure reproducibility across runs, use the [`~Trainer.model_init`] function to instantiate the model if it has some randomly initialized parameters.
  data_seed: null  # Random seed to be used with data samplers. If not set, random generators for data sampling will use the same seed as `seed`. This can be used to ensure reproducibility of data sampling, independent of the model seed.
  jit_mode_eval: False  # Whether or not to use PyTorch jit trace for inference.
  use_ipex: False   # Use Intel extension for PyTorch when it is available. [IPEX installation](https://github.com/intel/intel-extension-for-pytorch).
  bf16: False  # Whether to use bf16 16-bit (mixed) precision training instead of 32-bit training. Requires Ampere or higher NVIDIA architecture or using CPU (use_cpu) or Ascend NPU. This is an experimental API and it may change.
  fp16: False  # Whether to use fp16 16-bit (mixed) precision training instead of 32-bit training.
  fp16_opt_level: 'O1'  # For `fp16` training, Apex AMP optimization level selected in ['O0', 'O1', 'O2', and 'O3']. See details on the [Apex documentation](https://nvidia.github.io/apex/amp).
  half_precision_backend: 'auto'  # The backend to use for mixed precision training. Must be one of `"auto", "apex", "cpu_amp"`. `"auto"` will use CPU/CUDA AMP or APEX depending on the PyTorch version detected, while the other choices will force the requested backend.
  bf16_full_eval: False  # Whether to use full bfloat16 evaluation instead of 32-bit. This will be faster and save memory but can harm metric values. This is an experimental API and it may change. 
  fp16_full_eval: False  # Whether to use full float16 evaluation instead of 32-bit. This will be faster and save memory but can harm metric values.
  tf32: null  # Wether to enable the TF32 mode, available in Ampere and newer GPU architectures. The default value depends on PyTorch's version default of `torch.backends.cuda.matmul.allow_tf32`. For more details please refer to the [TF32](https://huggingface.co/docs/transformers/performance#tf32) documentation. This is an experimental API and it may change.
  local_rank: -1  # Rank of the process during distributed training.
  ddp_backend: null  # The backend to use for distributed training. Must be one of `"nccl"`, `"mpi"`, `"ccl"`, `"gloo"`, `"hccl"`.
  tpu_num_cores: null  # When training on TPU, the number of TPU cores (automatically passed by launcher script).
  tpu_metrics_debug: False
  debug: ''  # Enable one or more debug features. This is an experimental feature. Possible options are: - `"underflow_overflow"`: detects overflow in model's input/outputs and reports the last frames that led to the event - `"tpu_metrics_debug"`: print debug metrics on TPU The options should be separated by whitespaces.
  dataloader_drop_last: False  # Whether to drop the last incomplete batch (if the length of the dataset is not divisible by the batch size) or not.
  eval_steps: null  # Number of update steps between two evaluations if `eval_strategy="steps"`. Will default to the same value as `logging_steps` if not set. Should be an integer or a float in range `[0,1)`. If smaller than 1, will be interpreted as ratio of total training steps.
  dataloader_num_workers: 0  # Number of subprocesses to use for data loading (PyTorch only). 0 means that the data will be loaded in the main process.
  dataloader_prefetch_factor: null
  past_index: -1  # Some models like [TransformerXL](../model_doc/transformerxl) or [XLNet](../model_doc/xlnet) can make use of the past hidden states for their predictions. If this argument is set to a positive int, the `Trainer` will use the corresponding output (usually index 2) as the past state and feed it to the model at the next training step under the keyword argument `mems`.
  run_name: null  # A descriptor for the run. Typically used for [wandb](https://www.wandb.com/) and [mlflow](https://www.mlflow.org/) logging. If not specified, will be the same as `output_dir`.
  disable_tqdm: null  # Whether or not to disable the tqdm progress bars and table of metrics produced by [`~notebook.NotebookTrainingTracker`] in Jupyter Notebooks. Will default to `True` if the logging level is set to warn or lower (default), `False` otherwise.
  remove_unused_columns: True  # Whether or not to automatically remove the columns unused by the model forward method.
  label_names: null  # The list of keys in your dictionary of inputs that correspond to the labels. Will eventually default to the list of argument names accepted by the model that contain the word "label", except if the model used is one of the `XxxForQuestionAnswering` in which case it will also include the `["start_positions", "end_positions"]` keys.
  load_best_model_at_end: False  # Whether or not to load the best model found during training at the end of training. When this option is enabled, the best checkpoint will always be saved. See [`save_total_limit`](https://huggingface.co/docs/transformers/main_classes/trainer#transformers.TrainingArguments.save_total_limit) for more. When set to `True`, the parameters `save_strategy` needs to be the same as `eval_strategy`, and in the case it is "steps", `save_steps` must be a round multiple of `eval_steps`.
  metric_for_best_model: null  # Use in conjunction with `load_best_model_at_end` to specify the metric to use to compare two different models. Must be the name of a metric returned by the evaluation with or without the prefix `"eval_"`. Will default to `"loss"` if unspecified and load_best_model_at_end=True` (to use the evaluation loss). If you set this value, `greater_is_better` will default to `True`. Don't forget to set it to `False` if your metric is better when lower.
  greater_is_better: null  # Use in conjunction with `load_best_model_at_end` and `metric_for_best_model` to specify if better models should have a greater metric or not. Will default to: - `True` if `metric_for_best_model` is set to a value that isn't `"loss"` or `"eval_loss"`. - `False` if `metric_for_best_model` is not set, or set to `"loss"` or `"eval_loss"`.
  ignore_data_skip: False  # When resuming training, whether or not to skip the epochs and batches to get the data loading at the same stage as in the previous training. If set to `True`, the training will begin faster (as that skipping step can take a long time) but will not yield the same results as the interrupted training would have.
  fsdp: ''  # Use PyTorch Distributed Parallel Training (in distributed training only). A list of options along the following: - `"full_shard"`: Shard parameters, gradients and optimizer states. - `"shard_grad_op"`: Shard optimizer states and gradients. - `"hybrid_shard"`: Apply FULL_SHARD` within a node, and replicate parameters across nodes. - `"hybrid_shard_zero2"`: Apply `SHARD_GRAD_OP` within a node, and replicate parameters across nodes. - `"offload"`: Offload parameters and gradients to CPUs (only compatible with `"full_shard"` and `"shard_grad_op"`). - `"auto_wrap"`: Automatically recursively wrap layers with FSDP using `default_auto_wrap_policy`.
  fsdp_min_num_params: 0
  fsdp_config: null  # Config to be used with fsdp (Pytorch Distributed Parallel Training). The value is either a location of fsdp json config file (e.g., `fsdp_config.json`) or an already loaded json file as `dict`. A List of config and its options: - min_num_params (`int`, *optional*, defaults to `0`): FSDP's minimum number of parameters for Default Auto Wrapping. (useful only when `fsdp` field is passed). - transformer_layer_cls_to_wrap (`List[str]`, *optional*): List of transformer layer class names (case-sensitive) to wrap, e.g, `BertLayer`, `GPTJBlock`, `T5Block` .... (useful only when `fsdp` flag is passed). - backward_prefetch (`str`, *optional*) FSDP's backward prefetch mode. Controls when to prefetch next set of parameters (useful only when `fsdp` field is passed). A list of options along the following: - `"backward_pre"` : Prefetches the next set of parameters before the current set of parameter's gradient computation. - `"backward_post"` : This prefetches the next set of parameters after the current set of parameterâ€™s gradient computation. - forward_prefetch (`bool`, *optional*, defaults to `False`) FSDP's forward prefetch mode (useful only when `fsdp` field is passed). If `"True"`, then FSDP explicitly prefetches the next upcoming all-gather while executing in the forward pass. - limit_all_gathers (`bool`, *optional*, defaults to `False`) FSDP's limit_all_gathers (useful only when `fsdp` field is passed). If `"True"`, FSDP explicitly synchronizes the CPU thread to prevent too many in-flight all-gathers. - use_orig_params (`bool`, *optional*, defaults to `True`) If `"True"`, allows non-uniform `requires_grad` during init, which means support for interspersed frozen and trainable paramteres. Useful in cases such as parameter-efficient fine-tuning. Please refer this [blog](https://dev-discuss.pytorch.org/t/rethinking-pytorch-fully-sharded-data-parallel-fsdp-from-first-principles/1019 - sync_module_states (`bool`, *optional*, defaults to `True`) If `"True"`, each individually wrapped FSDP unit will broadcast module parameters from rank 0 to ensure they are the same across all ranks after initialization - cpu_ram_efficient_loading (`bool`, *optional*, defaults to `False`) If `"True"`, only the first process loads the pretrained model checkpoint while all other processes have empty weights.  When this setting as `"True"`, `sync_module_states` also must to be `"True"`, otherwise all the processes except the main process would have random weights leading to unexpected behaviour during training. - activation_checkpointing (`bool`, *optional*, defaults to `False`): If `"True"`, activation checkpointing is a technique to reduce memory usage by clearing activations of certain layers and recomputing them during a backward pass. Effectively, this trades extra computation time for reduced memory usage. - xla (`bool`, *optional*, defaults to `False`): Whether to use PyTorch/XLA Fully Sharded Data Parallel Training. This is an experimental feature and its API may evolve in the future. - xla_fsdp_settings (`dict`, *optional*) The value is a dictionary which stores the XLA FSDP wrapping parameters. For a complete list of options, please see [here]( https://github.com/pytorch/xla/blob/master/torch_xla/distributed/fsdp/xla_fully_sharded_data_parallel.py). - xla_fsdp_grad_ckpt (`bool`, *optional*, defaults to `False`): Will use gradient checkpointing over each nested XLA FSDP wrapped layer. This setting can only be used when the xla flag is set to true, and an auto wrapping policy is specified through fsdp_min_num_params or fsdp_transformer_layer_cls_to_wrap.
  fsdp_transformer_layer_cls_to_wrap: null
  accelerator_config: null  # Config to be used with the internal `Accelerator` implementation. The value is either a location of accelerator json config file (e.g., `accelerator_config.json`), an already loaded json file as `dict`, or an instance of [`~trainer_pt_utils.AcceleratorConfig`]. A list of config and its options: - split_batches (`bool`, *optional*, defaults to `False`): Whether or not the accelerator should split the batches yielded by the dataloaders across the devices. If `True` the actual batch size used will be the same on any kind of distributed processes, but it must be a round multiple of the `num_processes` you are using. If `False`, actual batch size used will be the one set in your script multiplied by the number of processes. - dispatch_batches (`bool`, *optional*): If set to `True`, the dataloader prepared by the Accelerator is only iterated through on the main process and then the batches are split and broadcast to each process. Will default to `True` for `DataLoader` whose underlying dataset is an `IterableDataset`, `False` otherwise. - even_batches (`bool`, *optional*, defaults to `True`): If set to `True`, in cases where the total batch size across all processes does not exactly divide the dataset, samples at the start of the dataset will be duplicated so the batch can be divided equally among all workers. - use_seedable_sampler (`bool`, *optional*, defaults to `True`): Whether or not use a fully seedable random sampler ([`accelerate.data_loader.SeedableRandomSampler`]). Ensures training results are fully reproducable using a different sampling technique. While seed-to-seed results may differ, on average the differences are neglible when using multiple different seeds to compare. Should also be ran with [`~utils.set_seed`] for the best results.
  deepspeed: null  # Use [Deepspeed](https://github.com/microsoft/deepspeed). This is an experimental feature and its API may evolve in the future. The value is either the location of DeepSpeed json config file (e.g., `ds_config.json`) or an already loaded json file as a `dict`" If enabling any Zero-init, make sure that your model is not initialized until *after* initializing the `TrainingArguments`, else it will not be applied.
  label_smoothing_factor: 0.0  # The label smoothing factor to use. Zero means no label smoothing, otherwise the underlying onehot-encoded labels are changed from 0s and 1s to `label_smoothing_factor/num_labels` and `1 - label_smoothing_factor + label_smoothing_factor/num_labels` respectively.
  optim: 'adamw_torch'  # The optimizer to use: adamw_hf, adamw_torch, adamw_torch_fused, adamw_apex_fused, adamw_anyprecision or adafactor.
  optim_args: null  # Optional arguments that are supplied to AnyPrecisionAdamW.
  adafactor: False
  group_by_length: False  # Whether or not to group together samples of roughly the same length in the training dataset (to minimize padding applied and be more efficient). Only useful if applying dynamic padding.
  length_column_name: 'length'  # Column name for precomputed lengths. If the column exists, grouping by length will use these values rather than computing them on train startup. Ignored unless `group_by_length` is `True` and the dataset is an instance of `Dataset`.
  report_to: null  # The list of integrations to report the results and logs to. Supported platforms are `"azure_ml"`, `"clearml"`, `"codecarbon"`, `"comet_ml"`, `"dagshub"`, `"dvclive"`, `"flyte"`, `"mlflow"`, `"neptune"`, `"tensorboard"`, and `"wandb"`. Use `"all"` to report to all integrations installed, `"none"` for no integrations.
  ddp_find_unused_parameters: null  # When using distributed training, the value of the flag `find_unused_parameters` passed to `DistributedDataParallel`. Will default to `False` if gradient checkpointing is used, `True` otherwise.
  ddp_bucket_cap_mb: null  # When using distributed training, the value of the flag `bucket_cap_mb` passed to `DistributedDataParallel`.
  ddp_broadcast_buffers: null  # When using distributed training, the value of the flag `broadcast_buffers` passed to `DistributedDataParallel`. Will default to `False` if gradient checkpointing is used, `True` otherwise.
  dataloader_pin_memory: True  # Whether you want to pin memory in data loaders or not. Will default to `True`.
  dataloader_persistent_workers: False  # If True, the data loader will not shut down the worker processes after a dataset has been consumed once. This allows to maintain the workers Dataset instances alive. Can potentially speed up training, but will increase RAM usage. Will default to `False`.
  skip_memory_metrics: True  # Whether to skip adding of memory profiler reports to metrics. This is skipped by default because it slows down the training and evaluation speed.
  use_legacy_prediction_loop: False
  push_to_hub: False  # Whether or not to push the model to the Hub every time the model is saved. If this is activated, `output_dir` will begin a git directory synced with the repo (determined by `hub_model_id`) and the content will be pushed each time a save is triggered (depending on your `save_strategy`). Calling [`~Trainer.save_model`] will also trigger a push. If `output_dir` exists, it needs to be a local clone of the repository to which the [`Trainer`] will be pushed. 
  resume_from_checkpoint: null  # The path to a folder with a valid checkpoint for your model. This argument is not directly used by [`Trainer`], it's intended to be used by your training/evaluation scripts instead. See the [example scripts](https://github.com/huggingface/transformers/tree/main/examples) for more details.
  hub_model_id: null  # The name of the repository to keep in sync with the local *output_dir*. It can be a simple model ID in which case the model will be pushed in your namespace. Otherwise it should be the whole repository name, for instance `"user_name/model"`, which allows you to push to an organization you are a member of with `"organization_name/model"`. Will default to `user_name/output_dir_name` with *output_dir_name* being the name of `output_dir`. Will default to the name of `output_dir`.
  hub_strategy: 'every_save'  # Defines the scope of what is pushed to the Hub and when. Possible values are: - `"end"`: push the model, its configuration, the tokenizer (if passed along to the [`Trainer`]) and a draft of a model card when the [`~Trainer.save_model`] method is called. - `"every_save"`: push the model, its configuration, the tokenizer (if passed along to the [`Trainer`]) and a draft of a model card each time there is a model save. The pushes are asynchronous to not block training, and in case the save are very frequent, a new push is only attempted if the previous one is finished. A last push is made with the final model at the end of training. - `"checkpoint"`: like `"every_save"` but the latest checkpoint is also pushed in a subfolder named last-checkpoint, allowing you to resume training easily with `trainer.train (resume_from_checkpoint="last-checkpoint")`. - `"all_checkpoints"`: like `"checkpoint"` but all checkpoints are pushed like they appear in the output folder (so you will get one checkpoint folder per folder in your final repository)
  hub_token: null  # The token to use to push the model to the Hub. Will default to the token in the cache folder obtained with `huggingface-cli login`.
  hub_private_repo: False  # If True, the Hub repo will be set to private.
  hub_always_push: False  # Unless this is `True`, the `Trainer` will skip pushing a checkpoint when the previous push is not finished.
  gradient_checkpointing: False  # If True, use gradient checkpointing to save memory at the expense of slower backward pass.
  gradient_checkpointing_kwargs: null  # Key word arguments to be passed to the `gradient_checkpointing_enable` method.
  include_inputs_for_metrics: False  # Whether or not the inputs will be passed to the `compute_metrics` function. This is intended for metrics that need inputs, predictions and references for scoring calculation in Metric class.
  fp16_backend: 'auto'  # This argument is deprecated. Use `half_precision_backend` instead.
  evaluation_strategy: 'no'
  push_to_hub_model_id: null
  push_to_hub_organization: null
  push_to_hub_token: null
  mp_parameters: ''
  auto_find_batch_size: False  # Whether to find a batch size that will fit into memory automatically through exponential decay, avoiding CUDA Out-of-Memory errors. Requires accelerate to be installed (`pip install accelerate`)
  full_determinism: False  # If `True`, [`enable_full_determinism`] is called instead of [`set_seed`] to ensure reproducible results in distributed training. Important: this will negatively impact the performance, so only use it for debugging.
  torchdynamo: null  # If set, the backend compiler for TorchDynamo. Possible choices are `"eager"`, `"aot_eager"`, `"inductor"`, `"nvfuser"`, `"aot_nvfuser"`, `"aot_cudagraphs"`, `"ofi"`, `"fx2trt"`, `"onnxrt"` and `"ipex"`.
  ray_scope: 'last'  # The scope to use when doing hyperparameter search with Ray. By default, `"last"` will be used. Ray will then use the last checkpoint of all trials, compare those, and select the best one. However, other options are also available. See the [Ray documentation]( https://docs.ray.io/en/latest/tune/api_docs/analysis.html#ray.tune.ExperimentAnalysis.get_best_trial) for more options.
  ddp_timeout: 1800  # The timeout for `torch.distributed.init_process_group` calls, used to avoid GPU socket timeouts when performing slow operations in distributed runnings. Please refer the [PyTorch documentation] (https://pytorch.org/docs/stable/distributed.html#torch.distributed.init_process_group) for more information.
  torch_compile: False  # Whether or not to compile the model using PyTorch 2.0 [`torch.compile`](https://pytorch.org/get-started/pytorch-2.0/). This will use the best defaults for the [`torch.compile` API](https://pytorch.org/docs/stable/generated/torch.compile.html?highlight=torch+compile#torch.compile). You can customize the defaults with the argument `torch_compile_backend` and `torch_compile_mode` but we don't guarantee any of them will work as the support is progressively rolled in in PyTorch. This flag and the whole compile API is experimental and subject to change in future releases.
  torch_compile_backend: null  # The backend to use in `torch.compile`. If set to any value, `torch_compile` will be set to `True`. Refer to the PyTorch doc for possible values and note that they may change across PyTorch versions. This flag is experimental and subject to change in future releases.
  torch_compile_mode: null  # The mode to use in `torch.compile`. If set to any value, `torch_compile` will be set to `True`. Refer to the PyTorch doc for possible values and note that they may change across PyTorch versions. This flag is experimental and subject to change in future releases.
  dispatch_batches: null
  split_batches: null  # Whether or not the accelerator should split the batches yielded by the dataloaders across the devices during distributed training. If set to `True`, the actual batch size used will be the same on any kind of distributed processes, but it must be a round multiple of the number of processes you are using (such as GPUs).
  include_tokens_per_second: False  # Whether or not to compute the number of tokens per second per device for training speed metrics. This will iterate over the entire training dataloader once beforehand, and will slow down the entire process.
  include_num_input_tokens_seen: False  # Whether or not to track the number of input tokens seen throughout training. May be slower in distributed training as gather operations must be called.
